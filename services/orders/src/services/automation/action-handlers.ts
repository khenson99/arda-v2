/**
 * Automation Action Handlers
 *
 * Per-action handler functions for the TCAAF pipeline. Each handler
 * delegates to existing service modules for actual business logic,
 * keeping this layer focused on orchestration concerns.
 *
 * The `dispatchAction` switch dispatches to the correct handler
 * based on the ActionType discriminant.
 *
 * PO creation, email dispatch, and shopping list actions now delegate
 * to normalized ActionAdapter implementations for testability and
 * consistent error handling.
 */

import { db, schema } from '@arda/db';
import { eq, and } from 'drizzle-orm';
import { getEventBus } from '@arda/events';
import { config, createLogger } from '@arda/config';
import { createWorkOrderFromTrigger } from '../work-order-orchestration.service.js';
import { processExceptionAutomation } from '../exception-automation.service.js';
import {
  POCreationAdapter,
  EmailActionAdapter,
  EventBusEmailBackend,
  ShoppingListAdapter,
  EventBusShoppingListPublisher,
} from './adapters/index.js';
import type {
  POPersistence,
  POGuardrailChecker,
  POEventPublisher,
  ShoppingListPersistence,
} from './adapters/index.js';
import type {
  ActionType,
  PurchaseOrderContext,
  WorkOrderContext,
  TransferOrderContext,
  EmailDispatchContext,
  ShoppingListContext,
  CardTransitionContext,
  ExceptionResolutionContext,
} from './types.js';

const log = createLogger('automation:action-handlers');

const {
  purchaseOrders,
  purchaseOrderLines,
  transferOrders,
  kanbanCards,
  auditLog,
} = schema;

// ─── Handler Result ──────────────────────────────────────────────────

export interface ActionHandlerResult {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

// ─── Dispatch ────────────────────────────────────────────────────────

/**
 * Dispatch an action to its appropriate handler.
 *
 * @param actionType - The type of action to execute
 * @param params - Action-specific parameters
 * @returns Handler result with success flag and optional data
 */
export async function dispatchAction(
  actionType: ActionType,
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  log.info({ actionType }, 'Dispatching action');

  switch (actionType) {
    case 'create_purchase_order':
      return handleCreatePurchaseOrder(params as unknown as PurchaseOrderContext);

    case 'create_work_order':
      return handleCreateWorkOrder(params as unknown as WorkOrderContext);

    case 'create_transfer_order':
      return handleCreateTransferOrder(params as unknown as TransferOrderContext);

    case 'dispatch_email':
      return handleDispatchEmail(params as unknown as EmailDispatchContext);

    case 'add_to_shopping_list':
      return handleAddToShoppingList(params);

    case 'transition_card':
      return handleTransitionCard(params as unknown as CardTransitionContext);

    case 'resolve_exception':
      return handleResolveException(params as unknown as ExceptionResolutionContext);

    case 'escalate':
      return handleEscalate(params);

    default: {
      const _exhaustive: never = actionType;
      return { success: false, error: `Unknown action type: ${_exhaustive}` };
    }
  }
}

// ─── Adapter Factories ──────────────────────────────────────────────

/**
 * Build a POCreationAdapter wired to real DB + event-bus dependencies.
 * Each call returns a fresh adapter so tests can supply their own.
 */
function buildPOAdapter(): POCreationAdapter {
  const eventBus = getEventBus(config.REDIS_URL);

  const persistence: POPersistence = {
    async createPurchaseOrder(ctx) {
      const result = await db.transaction(async (tx) => {
        const poNumber = `PO-AUTO-${Date.now().toString(36).toUpperCase()}`;

        const [po] = await tx
          .insert(purchaseOrders)
          .values({
            tenantId: ctx.tenantId,
            poNumber,
            supplierId: ctx.supplierId,
            facilityId: ctx.facilityId,
            status: 'draft',
            totalAmount: String(ctx.totalAmount ?? 0),
            currency: 'USD',
            orderDate: new Date(),
            internalNotes: `Auto-generated by automation${ctx.isExpedited ? ' (expedited)' : ''}`,
          })
          .returning({ id: purchaseOrders.id, poNumber: purchaseOrders.poNumber })
          .execute();

        // Create the PO line
        await tx
          .insert(purchaseOrderLines)
          .values({
            tenantId: ctx.tenantId,
            purchaseOrderId: po.id,
            partId: ctx.partId,
            lineNumber: 1,
            kanbanCardId: ctx.cardId,
            quantityOrdered: ctx.orderQuantity,
            unitCost: String((ctx.totalAmount ?? 0) / ctx.orderQuantity),
            lineTotal: String(ctx.totalAmount ?? 0),
          })
          .execute();

        return po;
      });
      return { id: result.id, poNumber: result.poNumber };
    },

    async writeAuditLog(entry) {
      await db
        .insert(auditLog)
        .values({
          tenantId: entry.tenantId,
          entityType: entry.entityType,
          entityId: entry.entityId,
          action: entry.action,
          newState: entry.newState,
        })
        .execute();
    },
  };

  const guardrails: POGuardrailChecker = {
    async checkFinancial() {
      // Guardrails are checked earlier in the TCAAF pipeline (orchestrator).
      // The adapter receives pre-validated context, so we pass through here.
      return { passed: true, violations: [] };
    },
    async recordPOCreated() {
      // Counter tracking is handled by the guardrails module directly.
    },
  };

  const events: POEventPublisher = {
    async publishPOCreated(event) {
      await eventBus.publish({
        type: 'automation.po_created',
        tenantId: event.tenantId,
        purchaseOrderId: event.purchaseOrderId,
        poNumber: event.poNumber,
        source: 'automation',
        timestamp: new Date().toISOString(),
      });
    },
  };

  return new POCreationAdapter(persistence, guardrails, events);
}

function buildEmailAdapter(): EmailActionAdapter {
  const eventBus = getEventBus(config.REDIS_URL);
  const backend = new EventBusEmailBackend(
    (event) => eventBus.publish(event as unknown as Parameters<typeof eventBus.publish>[0]),
  );
  return new EmailActionAdapter(backend);
}

function buildShoppingListAdapter(): ShoppingListAdapter {
  const eventBus = getEventBus(config.REDIS_URL);

  const persistence: ShoppingListPersistence = {
    async addItem(item) {
      // Shopping list persistence is event-driven for now.
      // The catalog/items service handles storage on event receipt.
      const { buildGroupKey } = await import('./adapters/shopping-list.adapter.js');
      const groupKey = buildGroupKey(item.supplierId, item.facilityId, item.urgency);
      return {
        id: `sl-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
        partId: item.partId,
        quantity: item.quantity,
        groupKey,
      };
    },
  };

  const publisher = new EventBusShoppingListPublisher(
    (event) => eventBus.publish(event as unknown as Parameters<typeof eventBus.publish>[0]),
  );

  return new ShoppingListAdapter(persistence, publisher);
}

// ─── Individual Handlers ─────────────────────────────────────────────

/**
 * Create a draft purchase order via the POCreationAdapter.
 *
 * The adapter handles: DB transaction → audit log → guardrail counters → event.
 */
async function handleCreatePurchaseOrder(
  ctx: PurchaseOrderContext,
): Promise<ActionHandlerResult> {
  const adapter = buildPOAdapter();
  const result = await adapter.execute(ctx);
  return {
    success: result.success,
    data: result.data
      ? { purchaseOrderId: result.data.purchaseOrderId, poNumber: result.data.poNumber }
      : undefined,
    error: result.error,
  };
}

/**
 * Create a work order by delegating to the existing WO orchestration service.
 */
async function handleCreateWorkOrder(
  ctx: WorkOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await createWorkOrderFromTrigger({
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      partId: ctx.partId,
      facilityId: ctx.facilityId,
      quantity: ctx.orderQuantity,
    });

    log.info(
      { woId: result.workOrderId, woNumber: result.woNumber },
      'Work order created by automation',
    );

    return {
      success: true,
      data: {
        workOrderId: result.workOrderId,
        woNumber: result.woNumber,
        alreadyExisted: result.alreadyExisted,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create work order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Create a transfer order between facilities.
 */
async function handleCreateTransferOrder(
  ctx: TransferOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const toNumber = `TO-AUTO-${Date.now().toString(36).toUpperCase()}`;

    const [to] = await db
      .insert(transferOrders)
      .values({
        tenantId: ctx.tenantId,
        toNumber,
        sourceFacilityId: ctx.sourceFacilityId,
        destinationFacilityId: ctx.destFacilityId,
        status: 'requested',
        kanbanCardId: ctx.cardId,
        notes: `Auto-generated by automation. Quantity: ${ctx.orderQuantity}`,
      })
      .returning({ id: transferOrders.id, toNumber: transferOrders.toNumber })
      .execute();

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.to_created',
      tenantId: ctx.tenantId,
      transferOrderId: to.id,
      toNumber: to.toNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { toId: to.id, toNumber: to.toNumber },
      'Transfer order created by automation',
    );

    return {
      success: true,
      data: { transferOrderId: to.id, toNumber: to.toNumber },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create transfer order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Dispatch an email to a supplier via the EmailActionAdapter.
 *
 * The adapter handles: template rendering → delivery backend → status capture.
 */
async function handleDispatchEmail(
  ctx: EmailDispatchContext,
): Promise<ActionHandlerResult> {
  const adapter = buildEmailAdapter();
  const result = await adapter.execute(ctx);
  return {
    success: result.success,
    data: result.data
      ? { poId: ctx.poId, emailSent: true, messageId: result.data.messageId }
      : undefined,
    error: result.error,
  };
}

/**
 * Add an item to the tenant's shopping list via the ShoppingListAdapter.
 *
 * The adapter handles: grouping → persistence → event publishing.
 */
async function handleAddToShoppingList(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  const ctx: ShoppingListContext = {
    tenantId: params.tenantId as string,
    partId: params.partId as string,
    quantity: (params.quantity as number) ?? 1,
    supplierId: params.supplierId as string | undefined,
    facilityId: params.facilityId as string | undefined,
    urgency: (params.urgency as ShoppingListContext['urgency']) ?? 'normal',
    cardId: params.cardId as string | undefined,
    loopId: params.loopId as string | undefined,
    notes: params.notes as string | undefined,
  };

  const adapter = buildShoppingListAdapter();
  const result = await adapter.execute(ctx);
  return {
    success: result.success,
    data: result.data
      ? { added: true, recordId: result.data.recordId, groupKey: result.data.groupKey }
      : undefined,
    error: result.error,
  };
}

/**
 * Transition a kanban card to a new stage.
 */
async function handleTransitionCard(
  ctx: CardTransitionContext,
): Promise<ActionHandlerResult> {
  try {
    const now = new Date();

    await db
      .update(kanbanCards)
      .set({
        currentStage: ctx.toStage as (typeof kanbanCards.currentStage.enumValues)[number],
        currentStageEnteredAt: now,
        updatedAt: now,
      })
      .where(
        and(
          eq(kanbanCards.id, ctx.cardId),
          eq(kanbanCards.tenantId, ctx.tenantId),
        ),
      )
      .execute();

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.card_stage_changed',
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      fromStage: ctx.fromStage,
      toStage: ctx.toStage,
      cycleNumber: ctx.cycleNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { cardId: ctx.cardId, fromStage: ctx.fromStage, toStage: ctx.toStage },
      'Card transitioned by automation',
    );

    return {
      success: true,
      data: {
        cardId: ctx.cardId,
        fromStage: ctx.fromStage,
        toStage: ctx.toStage,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to transition card');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Resolve an exception by delegating to the exception automation service.
 */
async function handleResolveException(
  ctx: ExceptionResolutionContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await processExceptionAutomation(
      ctx.tenantId,
      ctx.exceptionId,
    );

    log.info(
      { exceptionId: ctx.exceptionId, action: result.action, success: result.success },
      'Exception resolved by automation',
    );

    return {
      success: result.success,
      data: {
        exceptionId: ctx.exceptionId,
        action: result.action,
        detail: result.detail,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to resolve exception');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Escalate an action that requires manual intervention.
 *
 * Publishes an escalation event and creates an audit log entry.
 */
async function handleEscalate(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  try {
    const tenantId = params.tenantId as string;
    const reason = (params.reason as string) ?? 'Automation escalation';

    // Audit log entry
    await db
      .insert(auditLog)
      .values({
        tenantId,
        entityType: (params.entityType as string) ?? 'automation',
        entityId: (params.entityId as string) ?? 'unknown',
        action: 'automation_escalated',
        newState: JSON.stringify({
          reason,
          source: 'automation_orchestrator',
          context: params,
        }),
      })
      .execute();

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.escalated',
      tenantId,
      reason,
      entityType: (params.entityType as string) ?? 'automation',
      entityId: (params.entityId as string) ?? 'unknown',
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.warn({ tenantId, reason }, 'Action escalated');

    return { success: true, data: { escalated: true, reason } };
  } catch (err) {
    log.error({ err, params }, 'Failed to escalate');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}
