/**
 * Automation Action Handlers
 *
 * Per-action handler functions for the TCAAF pipeline. Each handler
 * delegates to existing service modules for actual business logic,
 * keeping this layer focused on orchestration concerns.
 *
 * The `dispatchAction` switch dispatches to the correct handler
 * based on the ActionType discriminant.
 */

import { db, withTenantContext, schema } from '@arda/db';
import { eq, and } from 'drizzle-orm';
import { getEventBus } from '@arda/events';
import { config, createLogger } from '@arda/config';
import { createWorkOrderFromTrigger } from '../work-order-orchestration.service.js';
import { processExceptionAutomation } from '../exception-automation.service.js';
import type {
  ActionType,
  PurchaseOrderContext,
  WorkOrderContext,
  TransferOrderContext,
  EmailDispatchContext,
  CardTransitionContext,
  ExceptionResolutionContext,
} from './types.js';
import { isValidUUID } from './types.js';

const log = createLogger('automation:action-handlers');

const {
  purchaseOrders,
  purchaseOrderLines,
  transferOrders,
  kanbanCards,
  auditLog,
} = schema;

// ─── Handler Result ──────────────────────────────────────────────────

export interface ActionHandlerResult {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

// ─── Dispatch ────────────────────────────────────────────────────────

/**
 * Dispatch an action to its appropriate handler.
 *
 * @param actionType - The type of action to execute
 * @param params - Action-specific parameters
 * @returns Handler result with success flag and optional data
 */
export async function dispatchAction(
  actionType: ActionType,
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  log.info({ actionType }, 'Dispatching action');

  switch (actionType) {
    case 'create_purchase_order':
      return handleCreatePurchaseOrder(params as unknown as PurchaseOrderContext);

    case 'create_work_order':
      return handleCreateWorkOrder(params as unknown as WorkOrderContext);

    case 'create_transfer_order':
      return handleCreateTransferOrder(params as unknown as TransferOrderContext);

    case 'dispatch_email':
      return handleDispatchEmail(params as unknown as EmailDispatchContext);

    case 'add_to_shopping_list':
      return handleAddToShoppingList(params);

    case 'transition_card':
      return handleTransitionCard(params as unknown as CardTransitionContext);

    case 'resolve_exception':
      return handleResolveException(params as unknown as ExceptionResolutionContext);

    case 'escalate':
      return handleEscalate(params);

    default: {
      const _exhaustive: never = actionType;
      return { success: false, error: `Unknown action type: ${_exhaustive}` };
    }
  }
}

// ─── Individual Handlers ─────────────────────────────────────────────

/**
 * Create a draft purchase order from automation context.
 *
 * Inserts a PO record with 'draft' status and creates the associated
 * PO line. Emits a po.created event.
 */
async function handleCreatePurchaseOrder(
  ctx: PurchaseOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await withTenantContext(ctx.tenantId, async (tx) => {
      // Generate next PO number
      const poNumber = `PO-AUTO-${Date.now().toString(36).toUpperCase()}`;

      const [po] = await tx
        .insert(purchaseOrders)
        .values({
          tenantId: ctx.tenantId,
          poNumber,
          supplierId: ctx.supplierId,
          facilityId: ctx.facilityId,
          status: 'draft',
          totalAmount: String(ctx.totalAmount ?? 0),
          currency: 'USD',
          orderDate: new Date(),
          internalNotes: `Auto-generated by automation${ctx.isExpedited ? ' (expedited)' : ''}`,
        })
        .returning({ id: purchaseOrders.id, poNumber: purchaseOrders.poNumber })
        .execute();

      // Create the PO line
      await tx
        .insert(purchaseOrderLines)
        .values({
          tenantId: ctx.tenantId,
          purchaseOrderId: po.id,
          partId: ctx.partId,
          lineNumber: 1,
          kanbanCardId: ctx.cardId,
          quantityOrdered: ctx.orderQuantity,
          unitCost: String((ctx.totalAmount ?? 0) / ctx.orderQuantity),
          lineTotal: String(ctx.totalAmount ?? 0),
        })
        .execute();

      // Audit log
      await tx
        .insert(auditLog)
        .values({
          tenantId: ctx.tenantId,
          entityType: 'purchase_order',
          entityId: po.id,
          action: 'automation_created',
          newState: JSON.stringify({
            poNumber: po.poNumber,
            supplierId: ctx.supplierId,
            amount: ctx.totalAmount,
            source: 'automation_orchestrator',
          }),
        })
        .execute();

      return po;
    });

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.po_created',
      tenantId: ctx.tenantId,
      purchaseOrderId: result.id,
      poNumber: result.poNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { poId: result.id, poNumber: result.poNumber },
      'Purchase order created by automation',
    );

    return {
      success: true,
      data: { purchaseOrderId: result.id, poNumber: result.poNumber },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create purchase order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Create a work order by delegating to the existing WO orchestration service.
 */
async function handleCreateWorkOrder(
  ctx: WorkOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await createWorkOrderFromTrigger({
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      partId: ctx.partId,
      facilityId: ctx.facilityId,
      quantity: ctx.orderQuantity,
    });

    log.info(
      { woId: result.workOrderId, woNumber: result.woNumber },
      'Work order created by automation',
    );

    return {
      success: true,
      data: {
        workOrderId: result.workOrderId,
        woNumber: result.woNumber,
        alreadyExisted: result.alreadyExisted,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create work order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Create a transfer order between facilities.
 */
async function handleCreateTransferOrder(
  ctx: TransferOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const toNumber = `TO-AUTO-${Date.now().toString(36).toUpperCase()}`;

    const [to] = await withTenantContext(ctx.tenantId, async (tx) =>
      tx
        .insert(transferOrders)
        .values({
          tenantId: ctx.tenantId,
          toNumber,
          sourceFacilityId: ctx.sourceFacilityId,
          destinationFacilityId: ctx.destFacilityId,
          status: 'requested',
          kanbanCardId: ctx.cardId,
          notes: `Auto-generated by automation. Quantity: ${ctx.orderQuantity}`,
        })
        .returning({ id: transferOrders.id, toNumber: transferOrders.toNumber })
        .execute(),
    );

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.to_created',
      tenantId: ctx.tenantId,
      transferOrderId: to.id,
      toNumber: to.toNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { toId: to.id, toNumber: to.toNumber },
      'Transfer order created by automation',
    );

    return {
      success: true,
      data: { transferOrderId: to.id, toNumber: to.toNumber },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create transfer order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Dispatch an email to a supplier.
 *
 * Note: Actual email sending is handled by the notifications service.
 * This handler publishes an event that the notifications service picks up.
 */
async function handleDispatchEmail(
  ctx: EmailDispatchContext,
): Promise<ActionHandlerResult> {
  try {
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.email_dispatched',
      tenantId: ctx.tenantId,
      purchaseOrderId: ctx.poId,
      supplierId: ctx.supplierId,
      supplierEmail: ctx.supplierEmail,
      totalAmount: ctx.totalAmount,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { poId: ctx.poId, supplierEmail: ctx.supplierEmail },
      'Email dispatch event published',
    );

    return {
      success: true,
      data: { poId: ctx.poId, emailSent: true },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to dispatch email');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Add an item to the tenant's shopping list.
 *
 * Publishes an event for the catalog/items service to handle.
 */
async function handleAddToShoppingList(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  try {
    const tenantId = params.tenantId as string;
    if (!isValidUUID(tenantId)) {
      return { success: false, error: 'Invalid tenant ID in shopping list action' };
    }

    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.shopping_list_item_added',
      tenantId,
      partId: params.partId as string,
      quantity: params.quantity as number,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info({ params }, 'Shopping list item added by automation');

    return { success: true, data: { added: true } };
  } catch (err) {
    log.error({ err, params }, 'Failed to add to shopping list');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Transition a kanban card to a new stage.
 */
async function handleTransitionCard(
  ctx: CardTransitionContext,
): Promise<ActionHandlerResult> {
  try {
    const now = new Date();

    await withTenantContext(ctx.tenantId, async (tx) =>
      tx
        .update(kanbanCards)
        .set({
          currentStage: ctx.toStage as (typeof kanbanCards.currentStage.enumValues)[number],
          currentStageEnteredAt: now,
          updatedAt: now,
        })
        .where(
          and(
            eq(kanbanCards.id, ctx.cardId),
            eq(kanbanCards.tenantId, ctx.tenantId),
          ),
        )
        .execute(),
    );

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.card_stage_changed',
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      fromStage: ctx.fromStage,
      toStage: ctx.toStage,
      cycleNumber: ctx.cycleNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { cardId: ctx.cardId, fromStage: ctx.fromStage, toStage: ctx.toStage },
      'Card transitioned by automation',
    );

    return {
      success: true,
      data: {
        cardId: ctx.cardId,
        fromStage: ctx.fromStage,
        toStage: ctx.toStage,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to transition card');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Resolve an exception by delegating to the exception automation service.
 */
async function handleResolveException(
  ctx: ExceptionResolutionContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await processExceptionAutomation(
      ctx.tenantId,
      ctx.exceptionId,
    );

    log.info(
      { exceptionId: ctx.exceptionId, action: result.action, success: result.success },
      'Exception resolved by automation',
    );

    return {
      success: result.success,
      data: {
        exceptionId: ctx.exceptionId,
        action: result.action,
        detail: result.detail,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to resolve exception');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Escalate an action that requires manual intervention.
 *
 * Publishes an escalation event and creates an audit log entry.
 */
async function handleEscalate(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  try {
    const tenantId = params.tenantId as string;
    if (!isValidUUID(tenantId)) {
      return { success: false, error: 'Invalid tenant ID in escalation action' };
    }
    const reason = (params.reason as string) ?? 'Automation escalation';

    // Audit log entry (tenant-scoped)
    await withTenantContext(tenantId, async (tx) =>
      tx
        .insert(auditLog)
        .values({
          tenantId,
          entityType: (params.entityType as string) ?? 'automation',
          entityId: (params.entityId as string) ?? 'unknown',
          action: 'automation_escalated',
          newState: JSON.stringify({
            reason,
            source: 'automation_orchestrator',
            context: params,
          }),
        })
        .execute(),
    );

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.escalated',
      tenantId,
      reason,
      entityType: (params.entityType as string) ?? 'automation',
      entityId: (params.entityId as string) ?? 'unknown',
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.warn({ tenantId, reason }, 'Action escalated');

    return { success: true, data: { escalated: true, reason } };
  } catch (err) {
    log.error({ err, params }, 'Failed to escalate');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}
